//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using DslModeling = global::Microsoft.VisualStudio.Modeling;
using DslDesign = global::Microsoft.VisualStudio.Modeling.Design;
namespace Company.MobileDSL
{
	/// <summary>
	/// DomainClass NamedElement
	/// </summary>
	[DslDesign::DisplayNameResource("Company.MobileDSL.NamedElement.DisplayName", typeof(global::Company.MobileDSL.MobileDSLDomainModel), "Company.MobileDSL.GeneratedCode.DomainModelResx")]
	[DslDesign::DescriptionResource("Company.MobileDSL.NamedElement.Description", typeof(global::Company.MobileDSL.MobileDSLDomainModel), "Company.MobileDSL.GeneratedCode.DomainModelResx")]
	[DslModeling::DomainModelOwner(typeof(global::Company.MobileDSL.MobileDSLDomainModel))]
	[global::System.CLSCompliant(true)]
	[global::System.Diagnostics.DebuggerDisplay("{GetType().Name,nq} (Name = {namePropertyStorage})")]
	[DslModeling::DomainObjectId("2ebb92f6-9499-40eb-8258-97f115170c92")]
	public abstract partial class NamedElement : DslModeling::ModelElement
	{
		#region Constructors, domain class Id
	
		/// <summary>
		/// NamedElement domain class Id.
		/// </summary>
		public static readonly new global::System.Guid DomainClassId = new global::System.Guid(0x2ebb92f6, 0x9499, 0x40eb, 0x82, 0x58, 0x97, 0xf1, 0x15, 0x17, 0x0c, 0x92);
		/// <summary>
		/// Constructor.
		/// </summary>
		/// <param name="partition">Partition where new element is to be created.</param>
		/// <param name="propertyAssignments">List of domain property id/value pairs to set once the element is created.</param>
		protected NamedElement(DslModeling::Partition partition, DslModeling::PropertyAssignment[] propertyAssignments)
			: base(partition, propertyAssignments)
		{
		}
		#endregion
		#region Name domain property code
		
		/// <summary>
		/// Name domain property Id.
		/// </summary>
		public static readonly global::System.Guid NameDomainPropertyId = new global::System.Guid(0xffab557b, 0x9574, 0x4bc2, 0x90, 0xd3, 0x6a, 0x29, 0xc9, 0xc4, 0xf3, 0x5d);
		
		/// <summary>
		/// Storage for Name
		/// </summary>
		private global::System.String namePropertyStorage = string.Empty;
		
		/// <summary>
		/// Gets or sets the value of Name domain property.
		/// </summary>
		[DslDesign::DisplayNameResource("Company.MobileDSL.NamedElement/Name.DisplayName", typeof(global::Company.MobileDSL.MobileDSLDomainModel), "Company.MobileDSL.GeneratedCode.DomainModelResx")]
		[DslDesign::DescriptionResource("Company.MobileDSL.NamedElement/Name.Description", typeof(global::Company.MobileDSL.MobileDSLDomainModel), "Company.MobileDSL.GeneratedCode.DomainModelResx")]
		[global::System.ComponentModel.DefaultValue("")]
		[DslModeling::ElementName]
		[DslModeling::DomainObjectId("ffab557b-9574-4bc2-90d3-6a29c9c4f35d")]
		public global::System.String Name
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get
			{
				return namePropertyStorage;
			}
			[global::System.Diagnostics.DebuggerStepThrough]
			set
			{
				NamePropertyHandler.Instance.SetValue(this, value);
			}
		}
		/// <summary>
		/// Value handler for the NamedElement.Name domain property.
		/// </summary>
		internal sealed partial class NamePropertyHandler : DslModeling::DomainPropertyValueHandler<NamedElement, global::System.String>
		{
			private NamePropertyHandler() { }
		
			/// <summary>
			/// Gets the singleton instance of the NamedElement.Name domain property value handler.
			/// </summary>
			public static readonly NamePropertyHandler Instance = new NamePropertyHandler();
		
			/// <summary>
			/// Gets the Id of the NamedElement.Name domain property.
			/// </summary>
			public sealed override global::System.Guid DomainPropertyId
			{
				[global::System.Diagnostics.DebuggerStepThrough]
				get
				{
					return NameDomainPropertyId;
				}
			}
			
			/// <summary>
			/// Gets a strongly-typed value of the property on specified element.
			/// </summary>
			/// <param name="element">Element which owns the property.</param>
			/// <returns>Property value.</returns>
			public override sealed global::System.String GetValue(NamedElement element)
			{
				if (element == null) throw new global::System.ArgumentNullException("element");
				return element.namePropertyStorage;
			}
		
			/// <summary>
			/// Sets property value on an element.
			/// </summary>
			/// <param name="element">Element which owns the property.</param>
			/// <param name="newValue">New property value.</param>
			public override sealed void SetValue(NamedElement element, global::System.String newValue)
			{
				if (element == null) throw new global::System.ArgumentNullException("element");
		
				global::System.String oldValue = GetValue(element);
				if (newValue != oldValue)
				{
					ValueChanging(element, oldValue, newValue);
					element.namePropertyStorage = newValue;
					ValueChanged(element, oldValue, newValue);
				}
			}
		}
		
		#endregion
	}
}
namespace Company.MobileDSL
{
	/// <summary>
	/// DomainClass ComponentModel
	/// </summary>
	[DslDesign::DisplayNameResource("Company.MobileDSL.ComponentModel.DisplayName", typeof(global::Company.MobileDSL.MobileDSLDomainModel), "Company.MobileDSL.GeneratedCode.DomainModelResx")]
	[DslDesign::DescriptionResource("Company.MobileDSL.ComponentModel.Description", typeof(global::Company.MobileDSL.MobileDSLDomainModel), "Company.MobileDSL.GeneratedCode.DomainModelResx")]
	[DslModeling::DomainModelOwner(typeof(global::Company.MobileDSL.MobileDSLDomainModel))]
	[global::System.CLSCompliant(true)]
	[DslModeling::DomainObjectId("498ff66b-ae7b-4af8-96bc-5df73a773b98")]
	public partial class ComponentModel : NamedElement
	{
		#region Constructors, domain class Id
	
		/// <summary>
		/// ComponentModel domain class Id.
		/// </summary>
		public static readonly new global::System.Guid DomainClassId = new global::System.Guid(0x498ff66b, 0xae7b, 0x4af8, 0x96, 0xbc, 0x5d, 0xf7, 0x3a, 0x77, 0x3b, 0x98);
		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="store">Store where new element is to be created.</param>
		/// <param name="propertyAssignments">List of domain property id/value pairs to set once the element is created.</param>
		public ComponentModel(DslModeling::Store store, params DslModeling::PropertyAssignment[] propertyAssignments)
			: this(store != null ? store.DefaultPartitionForClass(DomainClassId) : null, propertyAssignments)
		{
		}
		
		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="partition">Partition where new element is to be created.</param>
		/// <param name="propertyAssignments">List of domain property id/value pairs to set once the element is created.</param>
		public ComponentModel(DslModeling::Partition partition, params DslModeling::PropertyAssignment[] propertyAssignments)
			: base(partition, propertyAssignments)
		{
		}
		#endregion
		#region Comments opposite domain role accessor
		
		/// <summary>
		/// Gets a list of Comments.
		/// </summary>
		public virtual DslModeling::LinkedElementCollection<Comment> Comments
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get
			{
				return GetRoleCollection<DslModeling::LinkedElementCollection<Comment>, Comment>(global::Company.MobileDSL.ComponentModelHasComments.ComponentModelDomainRoleId);
			}
		}
		#endregion
		#region Controllers opposite domain role accessor
		
		/// <summary>
		/// Gets a list of Controllers.
		/// </summary>
		public virtual DslModeling::LinkedElementCollection<Controller> Controllers
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get
			{
				return GetRoleCollection<DslModeling::LinkedElementCollection<Controller>, Controller>(global::Company.MobileDSL.ComponentModelHasControllers.ComponentModelDomainRoleId);
			}
		}
		#endregion
		#region TempClassed opposite domain role accessor
		
		/// <summary>
		/// Gets a list of TempClassed.
		/// Description for Company.MobileDSL.ComponentModelHasTempClassed.ComponentModel
		/// </summary>
		public virtual DslModeling::LinkedElementCollection<TempClass> TempClassed
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get
			{
				return GetRoleCollection<DslModeling::LinkedElementCollection<TempClass>, TempClass>(global::Company.MobileDSL.ComponentModelHasTempClassed.ComponentModelDomainRoleId);
			}
		}
		#endregion
		#region ElementGroupPrototype Merge methods
		/// <summary>
		/// Returns a value indicating whether the source element represented by the
		/// specified root ProtoElement can be added to this element.
		/// </summary>
		/// <param name="rootElement">
		/// The root ProtoElement representing a source element.  This can be null, 
		/// in which case the ElementGroupPrototype does not contain an ProtoElements
		/// and the code should inspect the ElementGroupPrototype context information.
		/// </param>
		/// <param name="elementGroupPrototype">The ElementGroupPrototype that contains the root ProtoElement.</param>
		/// <returns>true if the source element represented by the ProtoElement can be added to this target element.</returns>
		protected override bool CanMerge(DslModeling::ProtoElementBase rootElement, DslModeling::ElementGroupPrototype elementGroupPrototype)
		{
			if ( elementGroupPrototype == null ) throw new global::System.ArgumentNullException("elementGroupPrototype");
			
			if (rootElement != null)
			{
				DslModeling::DomainClassInfo rootElementDomainInfo = this.Partition.DomainDataDirectory.GetDomainClass(rootElement.DomainClassId);
				
				if (rootElementDomainInfo.IsDerivedFrom(global::Company.MobileDSL.Controller.DomainClassId)) 
				{
					return true;
				}
				
				if (rootElementDomainInfo.IsDerivedFrom(global::Company.MobileDSL.Comment.DomainClassId)) 
				{
					return true;
				}
				
				if (rootElementDomainInfo.IsDerivedFrom(global::Company.MobileDSL.TempClass.DomainClassId)) 
				{
					return true;
				}
			}
			return base.CanMerge(rootElement, elementGroupPrototype);
		}
		
		/// <summary>
		/// Called by the Merge process to create a relationship between 
		/// this target element and the specified source element. 
		/// Typically, a parent-child relationship is established
		/// between the target element (the parent) and the source element 
		/// (the child), but any relationship can be established.
		/// </summary>
		/// <param name="sourceElement">The element that is to be related to this model element.</param>
		/// <param name="elementGroup">The group of source ModelElements that have been rehydrated into the target store.</param>
		/// <remarks>
		/// This method is overriden to create the relationship between the target element and the specified source element.
		/// The base method does nothing.
		/// </remarks>
		protected override void MergeRelate(DslModeling::ModelElement sourceElement, DslModeling::ElementGroup elementGroup)
		{
			// In general, sourceElement is allowed to be null, meaning that the elementGroup must be parsed for special cases.
			// However this is not supported in generated code.  Use double-deriving on this class and then override MergeRelate completely if you 
			// need to support this case.
			if ( sourceElement == null ) throw new global::System.ArgumentNullException("sourceElement");
		
				
			global::Company.MobileDSL.Controller sourceController1 = sourceElement as global::Company.MobileDSL.Controller;
			if (sourceController1 != null)
			{
				// Create link for path ComponentModelHasControllers.Controllers
				this.Controllers.Add(sourceController1);

				return;
			}
				
			global::Company.MobileDSL.Comment sourceComment2 = sourceElement as global::Company.MobileDSL.Comment;
			if (sourceComment2 != null)
			{
				// Create link for path ComponentModelHasComments.Comments
				this.Comments.Add(sourceComment2);

				return;
			}
				
			global::Company.MobileDSL.TempClass sourceTempClass3 = sourceElement as global::Company.MobileDSL.TempClass;
			if (sourceTempClass3 != null)
			{
				// Create link for path ComponentModelHasTempClassed.TempClassed
				this.TempClassed.Add(sourceTempClass3);

				return;
			}
		
			// Sdk workaround to runtime bug #879350 (DSL: can't copy and paste a MEL that has a MEX). Avoid MergeRelate on ModelElementExtension
			// during a "Paste".
			if (sourceElement is DslModeling::ExtensionElement
				&& sourceElement.Store.TransactionManager.CurrentTransaction.TopLevelTransaction.Context.ContextInfo.ContainsKey("{9DAFD42A-DC0E-4d78-8C3F-8266B2CF8B33}"))
			{
				return;
			}
		
			// Fall through to base class if this class hasn't handled the merge.
			base.MergeRelate(sourceElement, elementGroup);
		}
		
		/// <summary>
		/// Performs operation opposite to MergeRelate - i.e. disconnects a given
		/// element from the current one (removes links created by MergeRelate).
		/// </summary>
		/// <param name="sourceElement">Element to be unmerged/disconnected.</param>
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1800:DoNotCastUnnecessarily")]
		protected override void MergeDisconnect(DslModeling::ModelElement sourceElement)
		{
			if (sourceElement == null) throw new global::System.ArgumentNullException("sourceElement");
				
			global::Company.MobileDSL.Controller sourceController1 = sourceElement as global::Company.MobileDSL.Controller;
			if (sourceController1 != null)
			{
				// Delete link for path ComponentModelHasControllers.Controllers
				
				foreach (DslModeling::ElementLink link in global::Company.MobileDSL.ComponentModelHasControllers.GetLinks((global::Company.MobileDSL.ComponentModel)this, sourceController1))
				{
					// Delete the link, but without possible delete propagation to the element since it's moving to a new location.
					link.Delete(global::Company.MobileDSL.ComponentModelHasControllers.ComponentModelDomainRoleId, global::Company.MobileDSL.ComponentModelHasControllers.ControllerDomainRoleId);
				}

				return;
			}
				
			global::Company.MobileDSL.Comment sourceComment2 = sourceElement as global::Company.MobileDSL.Comment;
			if (sourceComment2 != null)
			{
				// Delete link for path ComponentModelHasComments.Comments
				
				foreach (DslModeling::ElementLink link in global::Company.MobileDSL.ComponentModelHasComments.GetLinks((global::Company.MobileDSL.ComponentModel)this, sourceComment2))
				{
					// Delete the link, but without possible delete propagation to the element since it's moving to a new location.
					link.Delete(global::Company.MobileDSL.ComponentModelHasComments.ComponentModelDomainRoleId, global::Company.MobileDSL.ComponentModelHasComments.CommentDomainRoleId);
				}

				return;
			}
				
			global::Company.MobileDSL.TempClass sourceTempClass3 = sourceElement as global::Company.MobileDSL.TempClass;
			if (sourceTempClass3 != null)
			{
				// Delete link for path ComponentModelHasTempClassed.TempClassed
				
				foreach (DslModeling::ElementLink link in global::Company.MobileDSL.ComponentModelHasTempClassed.GetLinks((global::Company.MobileDSL.ComponentModel)this, sourceTempClass3))
				{
					// Delete the link, but without possible delete propagation to the element since it's moving to a new location.
					link.Delete(global::Company.MobileDSL.ComponentModelHasTempClassed.ComponentModelDomainRoleId, global::Company.MobileDSL.ComponentModelHasTempClassed.TempClassDomainRoleId);
				}

				return;
			}
			// Fall through to base class if this class hasn't handled the unmerge.
			base.MergeDisconnect(sourceElement);
		}
		#endregion
	}
}
namespace Company.MobileDSL
{
	/// <summary>
	/// DomainClass Controller
	/// </summary>
	[DslDesign::DisplayNameResource("Company.MobileDSL.Controller.DisplayName", typeof(global::Company.MobileDSL.MobileDSLDomainModel), "Company.MobileDSL.GeneratedCode.DomainModelResx")]
	[DslDesign::DescriptionResource("Company.MobileDSL.Controller.Description", typeof(global::Company.MobileDSL.MobileDSLDomainModel), "Company.MobileDSL.GeneratedCode.DomainModelResx")]
	[DslModeling::DomainModelOwner(typeof(global::Company.MobileDSL.MobileDSLDomainModel))]
	[global::System.CLSCompliant(true)]
	[DslModeling::DomainObjectId("bb8866e4-0364-4829-9370-590d91c53c94")]
	public partial class Controller : NamedElement
	{
		#region Constructors, domain class Id
	
		/// <summary>
		/// Controller domain class Id.
		/// </summary>
		public static readonly new global::System.Guid DomainClassId = new global::System.Guid(0xbb8866e4, 0x0364, 0x4829, 0x93, 0x70, 0x59, 0x0d, 0x91, 0xc5, 0x3c, 0x94);
		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="store">Store where new element is to be created.</param>
		/// <param name="propertyAssignments">List of domain property id/value pairs to set once the element is created.</param>
		public Controller(DslModeling::Store store, params DslModeling::PropertyAssignment[] propertyAssignments)
			: this(store != null ? store.DefaultPartitionForClass(DomainClassId) : null, propertyAssignments)
		{
		}
		
		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="partition">Partition where new element is to be created.</param>
		/// <param name="propertyAssignments">List of domain property id/value pairs to set once the element is created.</param>
		public Controller(DslModeling::Partition partition, params DslModeling::PropertyAssignment[] propertyAssignments)
			: base(partition, propertyAssignments)
		{
		}
		#endregion
		#region Kind domain property code
		
		/// <summary>
		/// Kind domain property Id.
		/// </summary>
		public static readonly global::System.Guid KindDomainPropertyId = new global::System.Guid(0x1a3638d1, 0xf772, 0x4430, 0xa2, 0xac, 0x00, 0x82, 0x26, 0xa8, 0x03, 0xea);
		
		/// <summary>
		/// Storage for Kind
		/// </summary>
		private global::System.String kindPropertyStorage = string.Empty;
		
		/// <summary>
		/// Gets or sets the value of Kind domain property.
		/// </summary>
		[DslDesign::DisplayNameResource("Company.MobileDSL.Controller/Kind.DisplayName", typeof(global::Company.MobileDSL.MobileDSLDomainModel), "Company.MobileDSL.GeneratedCode.DomainModelResx")]
		[DslDesign::DescriptionResource("Company.MobileDSL.Controller/Kind.Description", typeof(global::Company.MobileDSL.MobileDSLDomainModel), "Company.MobileDSL.GeneratedCode.DomainModelResx")]
		[global::System.ComponentModel.DefaultValue("")]
		[DslModeling::DomainObjectId("1a3638d1-f772-4430-a2ac-008226a803ea")]
		public global::System.String Kind
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get
			{
				return kindPropertyStorage;
			}
			[global::System.Diagnostics.DebuggerStepThrough]
			set
			{
				KindPropertyHandler.Instance.SetValue(this, value);
			}
		}
		/// <summary>
		/// Value handler for the Controller.Kind domain property.
		/// </summary>
		internal sealed partial class KindPropertyHandler : DslModeling::DomainPropertyValueHandler<Controller, global::System.String>
		{
			private KindPropertyHandler() { }
		
			/// <summary>
			/// Gets the singleton instance of the Controller.Kind domain property value handler.
			/// </summary>
			public static readonly KindPropertyHandler Instance = new KindPropertyHandler();
		
			/// <summary>
			/// Gets the Id of the Controller.Kind domain property.
			/// </summary>
			public sealed override global::System.Guid DomainPropertyId
			{
				[global::System.Diagnostics.DebuggerStepThrough]
				get
				{
					return KindDomainPropertyId;
				}
			}
			
			/// <summary>
			/// Gets a strongly-typed value of the property on specified element.
			/// </summary>
			/// <param name="element">Element which owns the property.</param>
			/// <returns>Property value.</returns>
			public override sealed global::System.String GetValue(Controller element)
			{
				if (element == null) throw new global::System.ArgumentNullException("element");
				return element.kindPropertyStorage;
			}
		
			/// <summary>
			/// Sets property value on an element.
			/// </summary>
			/// <param name="element">Element which owns the property.</param>
			/// <param name="newValue">New property value.</param>
			public override sealed void SetValue(Controller element, global::System.String newValue)
			{
				if (element == null) throw new global::System.ArgumentNullException("element");
		
				global::System.String oldValue = GetValue(element);
				if (newValue != oldValue)
				{
					ValueChanging(element, oldValue, newValue);
					element.kindPropertyStorage = newValue;
					ValueChanged(element, oldValue, newValue);
				}
			}
		}
		
		#endregion
		#region isFirst domain property code
		
		/// <summary>
		/// isFirst domain property Id.
		/// </summary>
		public static readonly global::System.Guid isFirstDomainPropertyId = new global::System.Guid(0xbc8f3b2c, 0xa70e, 0x4f1e, 0x86, 0xa8, 0xc2, 0xf3, 0xba, 0xa4, 0xa2, 0x14);
		
		/// <summary>
		/// Storage for isFirst
		/// </summary>
		private global::System.Boolean isFirstPropertyStorage;
		
		/// <summary>
		/// Gets or sets the value of isFirst domain property.
		/// Description for Company.MobileDSL.Controller.Is First
		/// </summary>
		[DslDesign::DisplayNameResource("Company.MobileDSL.Controller/isFirst.DisplayName", typeof(global::Company.MobileDSL.MobileDSLDomainModel), "Company.MobileDSL.GeneratedCode.DomainModelResx")]
		[DslDesign::DescriptionResource("Company.MobileDSL.Controller/isFirst.Description", typeof(global::Company.MobileDSL.MobileDSLDomainModel), "Company.MobileDSL.GeneratedCode.DomainModelResx")]
		[DslModeling::DomainObjectId("bc8f3b2c-a70e-4f1e-86a8-c2f3baa4a214")]
		public global::System.Boolean isFirst
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get
			{
				return isFirstPropertyStorage;
			}
			[global::System.Diagnostics.DebuggerStepThrough]
			set
			{
				isFirstPropertyHandler.Instance.SetValue(this, value);
			}
		}
		/// <summary>
		/// Value handler for the Controller.isFirst domain property.
		/// </summary>
		internal sealed partial class isFirstPropertyHandler : DslModeling::DomainPropertyValueHandler<Controller, global::System.Boolean>
		{
			private isFirstPropertyHandler() { }
		
			/// <summary>
			/// Gets the singleton instance of the Controller.isFirst domain property value handler.
			/// </summary>
			public static readonly isFirstPropertyHandler Instance = new isFirstPropertyHandler();
		
			/// <summary>
			/// Gets the Id of the Controller.isFirst domain property.
			/// </summary>
			public sealed override global::System.Guid DomainPropertyId
			{
				[global::System.Diagnostics.DebuggerStepThrough]
				get
				{
					return isFirstDomainPropertyId;
				}
			}
			
			/// <summary>
			/// Gets a strongly-typed value of the property on specified element.
			/// </summary>
			/// <param name="element">Element which owns the property.</param>
			/// <returns>Property value.</returns>
			public override sealed global::System.Boolean GetValue(Controller element)
			{
				if (element == null) throw new global::System.ArgumentNullException("element");
				return element.isFirstPropertyStorage;
			}
		
			/// <summary>
			/// Sets property value on an element.
			/// </summary>
			/// <param name="element">Element which owns the property.</param>
			/// <param name="newValue">New property value.</param>
			public override sealed void SetValue(Controller element, global::System.Boolean newValue)
			{
				if (element == null) throw new global::System.ArgumentNullException("element");
		
				global::System.Boolean oldValue = GetValue(element);
				if (newValue != oldValue)
				{
					ValueChanging(element, oldValue, newValue);
					element.isFirstPropertyStorage = newValue;
					ValueChanged(element, oldValue, newValue);
				}
			}
		}
		
		#endregion
		#region Ports opposite domain role accessor
		
		/// <summary>
		/// Gets a list of Ports.
		/// </summary>
		public virtual DslModeling::LinkedElementCollection<Port> Ports
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get
			{
				return GetRoleCollection<DslModeling::LinkedElementCollection<Port>, Port>(global::Company.MobileDSL.ControllerHasPorts.ControllerDomainRoleId);
			}
		}
		#endregion
		#region ComponentModel opposite domain role accessor
		/// <summary>
		/// Gets or sets ComponentModel.
		/// </summary>
		public virtual ComponentModel ComponentModel
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get
			{
				return DslModeling::DomainRoleInfo.GetLinkedElement(this, global::Company.MobileDSL.ComponentModelHasControllers.ControllerDomainRoleId) as ComponentModel;
			}
			[global::System.Diagnostics.DebuggerStepThrough]
			set
			{
				DslModeling::DomainRoleInfo.SetLinkedElement(this, global::Company.MobileDSL.ComponentModelHasControllers.ControllerDomainRoleId, value);
			}
		}
		#endregion
		#region Subclasses opposite domain role accessor
		
		/// <summary>
		/// Gets a list of Subclasses.
		/// </summary>
		public virtual DslModeling::LinkedElementCollection<Controller> Subclasses
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get
			{
				return GetRoleCollection<DslModeling::LinkedElementCollection<Controller>, Controller>(global::Company.MobileDSL.Generalization.SuperclassDomainRoleId);
			}
		}
		#endregion
		#region Superclass opposite domain role accessor
		/// <summary>
		/// Gets or sets Superclass.
		/// </summary>
		public virtual Controller Superclass
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get
			{
				return DslModeling::DomainRoleInfo.GetLinkedElement(this, global::Company.MobileDSL.Generalization.SubclassDomainRoleId) as Controller;
			}
			[global::System.Diagnostics.DebuggerStepThrough]
			set
			{
				DslModeling::DomainRoleInfo.SetLinkedElement(this, global::Company.MobileDSL.Generalization.SubclassDomainRoleId, value);
			}
		}
		#endregion
		#region Comments opposite domain role accessor
		
		/// <summary>
		/// Gets a list of Comments.
		/// </summary>
		public virtual DslModeling::LinkedElementCollection<Comment> Comments
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get
			{
				return GetRoleCollection<DslModeling::LinkedElementCollection<Comment>, Comment>(global::Company.MobileDSL.CommentReferencesSubjects.SubjectDomainRoleId);
			}
		}
		#endregion
		#region States opposite domain role accessor
		
		/// <summary>
		/// Gets a list of States.
		/// Description for Company.MobileDSL.ControllerHasStates.Controller
		/// </summary>
		public virtual DslModeling::LinkedElementCollection<State_old> States
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get
			{
				return GetRoleCollection<DslModeling::LinkedElementCollection<State_old>, State_old>(global::Company.MobileDSL.ControllerHasStates.ControllerDomainRoleId);
			}
		}
		#endregion
		#region Stated opposite domain role accessor
		
		/// <summary>
		/// Gets a list of Stated.
		/// Description for Company.MobileDSL.ControllerHasStated.Controller
		/// </summary>
		public virtual DslModeling::LinkedElementCollection<State> Stated
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get
			{
				return GetRoleCollection<DslModeling::LinkedElementCollection<State>, State>(global::Company.MobileDSL.ControllerHasStated.ControllerDomainRoleId);
			}
		}
		#endregion
		#region ElementGroupPrototype Merge methods
		/// <summary>
		/// Returns a value indicating whether the source element represented by the
		/// specified root ProtoElement can be added to this element.
		/// </summary>
		/// <param name="rootElement">
		/// The root ProtoElement representing a source element.  This can be null, 
		/// in which case the ElementGroupPrototype does not contain an ProtoElements
		/// and the code should inspect the ElementGroupPrototype context information.
		/// </param>
		/// <param name="elementGroupPrototype">The ElementGroupPrototype that contains the root ProtoElement.</param>
		/// <returns>true if the source element represented by the ProtoElement can be added to this target element.</returns>
		protected override bool CanMerge(DslModeling::ProtoElementBase rootElement, DslModeling::ElementGroupPrototype elementGroupPrototype)
		{
			if ( elementGroupPrototype == null ) throw new global::System.ArgumentNullException("elementGroupPrototype");
			
			if (rootElement != null)
			{
				DslModeling::DomainClassInfo rootElementDomainInfo = this.Partition.DomainDataDirectory.GetDomainClass(rootElement.DomainClassId);
				
				if (rootElementDomainInfo.IsDerivedFrom(global::Company.MobileDSL.Port.DomainClassId)) 
				{
					return true;
				}
				
				if (rootElementDomainInfo.IsDerivedFrom(global::Company.MobileDSL.State_old.DomainClassId)) 
				{
					return true;
				}
				
				if (rootElementDomainInfo.IsDerivedFrom(global::Company.MobileDSL.State.DomainClassId)) 
				{
					return true;
				}
			}
			return base.CanMerge(rootElement, elementGroupPrototype);
		}
		
		/// <summary>
		/// Called by the Merge process to create a relationship between 
		/// this target element and the specified source element. 
		/// Typically, a parent-child relationship is established
		/// between the target element (the parent) and the source element 
		/// (the child), but any relationship can be established.
		/// </summary>
		/// <param name="sourceElement">The element that is to be related to this model element.</param>
		/// <param name="elementGroup">The group of source ModelElements that have been rehydrated into the target store.</param>
		/// <remarks>
		/// This method is overriden to create the relationship between the target element and the specified source element.
		/// The base method does nothing.
		/// </remarks>
		protected override void MergeRelate(DslModeling::ModelElement sourceElement, DslModeling::ElementGroup elementGroup)
		{
			// In general, sourceElement is allowed to be null, meaning that the elementGroup must be parsed for special cases.
			// However this is not supported in generated code.  Use double-deriving on this class and then override MergeRelate completely if you 
			// need to support this case.
			if ( sourceElement == null ) throw new global::System.ArgumentNullException("sourceElement");
		
				
			global::Company.MobileDSL.Port sourcePort1 = sourceElement as global::Company.MobileDSL.Port;
			if (sourcePort1 != null)
			{
				// Create link for path ControllerHasPorts.Ports
				this.Ports.Add(sourcePort1);

				return;
			}
				
			global::Company.MobileDSL.State_old sourceState_old2 = sourceElement as global::Company.MobileDSL.State_old;
			if (sourceState_old2 != null)
			{
				// Create link for path ControllerHasStates.States
				this.States.Add(sourceState_old2);

				return;
			}
				
			global::Company.MobileDSL.State sourceState3 = sourceElement as global::Company.MobileDSL.State;
			if (sourceState3 != null)
			{
				// Create link for path ControllerHasStated.Stated
				this.Stated.Add(sourceState3);

				return;
			}
		
			// Sdk workaround to runtime bug #879350 (DSL: can't copy and paste a MEL that has a MEX). Avoid MergeRelate on ModelElementExtension
			// during a "Paste".
			if (sourceElement is DslModeling::ExtensionElement
				&& sourceElement.Store.TransactionManager.CurrentTransaction.TopLevelTransaction.Context.ContextInfo.ContainsKey("{9DAFD42A-DC0E-4d78-8C3F-8266B2CF8B33}"))
			{
				return;
			}
		
			// Fall through to base class if this class hasn't handled the merge.
			base.MergeRelate(sourceElement, elementGroup);
		}
		
		/// <summary>
		/// Performs operation opposite to MergeRelate - i.e. disconnects a given
		/// element from the current one (removes links created by MergeRelate).
		/// </summary>
		/// <param name="sourceElement">Element to be unmerged/disconnected.</param>
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1800:DoNotCastUnnecessarily")]
		protected override void MergeDisconnect(DslModeling::ModelElement sourceElement)
		{
			if (sourceElement == null) throw new global::System.ArgumentNullException("sourceElement");
				
			global::Company.MobileDSL.Port sourcePort1 = sourceElement as global::Company.MobileDSL.Port;
			if (sourcePort1 != null)
			{
				// Delete link for path ControllerHasPorts.Ports
				
				foreach (DslModeling::ElementLink link in global::Company.MobileDSL.ControllerHasPorts.GetLinks((global::Company.MobileDSL.Controller)this, sourcePort1))
				{
					// Delete the link, but without possible delete propagation to the element since it's moving to a new location.
					link.Delete(global::Company.MobileDSL.ControllerHasPorts.ControllerDomainRoleId, global::Company.MobileDSL.ControllerHasPorts.PortDomainRoleId);
				}

				return;
			}
				
			global::Company.MobileDSL.State_old sourceState_old2 = sourceElement as global::Company.MobileDSL.State_old;
			if (sourceState_old2 != null)
			{
				// Delete link for path ControllerHasStates.States
				
				foreach (DslModeling::ElementLink link in global::Company.MobileDSL.ControllerHasStates.GetLinks((global::Company.MobileDSL.Controller)this, sourceState_old2))
				{
					// Delete the link, but without possible delete propagation to the element since it's moving to a new location.
					link.Delete(global::Company.MobileDSL.ControllerHasStates.ControllerDomainRoleId, global::Company.MobileDSL.ControllerHasStates.State_oldDomainRoleId);
				}

				return;
			}
				
			global::Company.MobileDSL.State sourceState3 = sourceElement as global::Company.MobileDSL.State;
			if (sourceState3 != null)
			{
				// Delete link for path ControllerHasStated.Stated
				
				foreach (DslModeling::ElementLink link in global::Company.MobileDSL.ControllerHasStated.GetLinks((global::Company.MobileDSL.Controller)this, sourceState3))
				{
					// Delete the link, but without possible delete propagation to the element since it's moving to a new location.
					link.Delete(global::Company.MobileDSL.ControllerHasStated.ControllerDomainRoleId, global::Company.MobileDSL.ControllerHasStated.StateDomainRoleId);
				}

				return;
			}
			// Fall through to base class if this class hasn't handled the unmerge.
			base.MergeDisconnect(sourceElement);
		}
		#endregion
	}
}
namespace Company.MobileDSL
{
	/// <summary>
	/// DomainClass Port
	/// Description for Company.MobileDSL.Port
	/// </summary>
	[DslDesign::DisplayNameResource("Company.MobileDSL.Port.DisplayName", typeof(global::Company.MobileDSL.MobileDSLDomainModel), "Company.MobileDSL.GeneratedCode.DomainModelResx")]
	[DslDesign::DescriptionResource("Company.MobileDSL.Port.Description", typeof(global::Company.MobileDSL.MobileDSLDomainModel), "Company.MobileDSL.GeneratedCode.DomainModelResx")]
	[DslModeling::DomainModelOwner(typeof(global::Company.MobileDSL.MobileDSLDomainModel))]
	[global::System.CLSCompliant(true)]
	[DslModeling::DomainObjectId("11ad2be7-4a6f-4090-b8c9-29388fbc1406")]
	public abstract partial class Port : NamedElement
	{
		#region Constructors, domain class Id
	
		/// <summary>
		/// Port domain class Id.
		/// </summary>
		public static readonly new global::System.Guid DomainClassId = new global::System.Guid(0x11ad2be7, 0x4a6f, 0x4090, 0xb8, 0xc9, 0x29, 0x38, 0x8f, 0xbc, 0x14, 0x06);
		/// <summary>
		/// Constructor.
		/// </summary>
		/// <param name="partition">Partition where new element is to be created.</param>
		/// <param name="propertyAssignments">List of domain property id/value pairs to set once the element is created.</param>
		protected Port(DslModeling::Partition partition, DslModeling::PropertyAssignment[] propertyAssignments)
			: base(partition, propertyAssignments)
		{
		}
		#endregion
		#region Controller opposite domain role accessor
		/// <summary>
		/// Gets or sets Controller.
		/// </summary>
		public virtual Controller Controller
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get
			{
				return DslModeling::DomainRoleInfo.GetLinkedElement(this, global::Company.MobileDSL.ControllerHasPorts.PortDomainRoleId) as Controller;
			}
			[global::System.Diagnostics.DebuggerStepThrough]
			set
			{
				DslModeling::DomainRoleInfo.SetLinkedElement(this, global::Company.MobileDSL.ControllerHasPorts.PortDomainRoleId, value);
			}
		}
		#endregion
		#region State_old opposite domain role accessor
		/// <summary>
		/// Gets or sets State_old.
		/// Description for Company.MobileDSL.State_oldHasPorts.Port
		/// </summary>
		public virtual State_old State_old
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get
			{
				return DslModeling::DomainRoleInfo.GetLinkedElement(this, global::Company.MobileDSL.State_oldHasPorts.PortDomainRoleId) as State_old;
			}
			[global::System.Diagnostics.DebuggerStepThrough]
			set
			{
				DslModeling::DomainRoleInfo.SetLinkedElement(this, global::Company.MobileDSL.State_oldHasPorts.PortDomainRoleId, value);
			}
		}
		#endregion
		#region State opposite domain role accessor
		/// <summary>
		/// Gets or sets State.
		/// Description for Company.MobileDSL.StateHasPorts.Port
		/// </summary>
		public virtual State State
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get
			{
				return DslModeling::DomainRoleInfo.GetLinkedElement(this, global::Company.MobileDSL.StateHasPorts.PortDomainRoleId) as State;
			}
			[global::System.Diagnostics.DebuggerStepThrough]
			set
			{
				DslModeling::DomainRoleInfo.SetLinkedElement(this, global::Company.MobileDSL.StateHasPorts.PortDomainRoleId, value);
			}
		}
		#endregion
		#region TempClass opposite domain role accessor
		/// <summary>
		/// Gets or sets TempClass.
		/// Description for Company.MobileDSL.TempClassHasPorts.Port
		/// </summary>
		public virtual TempClass TempClass
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get
			{
				return DslModeling::DomainRoleInfo.GetLinkedElement(this, global::Company.MobileDSL.TempClassHasPorts.PortDomainRoleId) as TempClass;
			}
			[global::System.Diagnostics.DebuggerStepThrough]
			set
			{
				DslModeling::DomainRoleInfo.SetLinkedElement(this, global::Company.MobileDSL.TempClassHasPorts.PortDomainRoleId, value);
			}
		}
		#endregion
	}
}
namespace Company.MobileDSL
{
	/// <summary>
	/// DomainClass InPort
	/// </summary>
	[DslDesign::DisplayNameResource("Company.MobileDSL.InPort.DisplayName", typeof(global::Company.MobileDSL.MobileDSLDomainModel), "Company.MobileDSL.GeneratedCode.DomainModelResx")]
	[DslDesign::DescriptionResource("Company.MobileDSL.InPort.Description", typeof(global::Company.MobileDSL.MobileDSLDomainModel), "Company.MobileDSL.GeneratedCode.DomainModelResx")]
	[DslModeling::DomainModelOwner(typeof(global::Company.MobileDSL.MobileDSLDomainModel))]
	[global::System.CLSCompliant(true)]
	[DslModeling::DomainObjectId("1fe64f7d-f422-4778-8f00-f111d94e9d10")]
	public partial class InPort : Port
	{
		#region Constructors, domain class Id
	
		/// <summary>
		/// InPort domain class Id.
		/// </summary>
		public static readonly new global::System.Guid DomainClassId = new global::System.Guid(0x1fe64f7d, 0xf422, 0x4778, 0x8f, 0x00, 0xf1, 0x11, 0xd9, 0x4e, 0x9d, 0x10);
		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="store">Store where new element is to be created.</param>
		/// <param name="propertyAssignments">List of domain property id/value pairs to set once the element is created.</param>
		public InPort(DslModeling::Store store, params DslModeling::PropertyAssignment[] propertyAssignments)
			: this(store != null ? store.DefaultPartitionForClass(DomainClassId) : null, propertyAssignments)
		{
		}
		
		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="partition">Partition where new element is to be created.</param>
		/// <param name="propertyAssignments">List of domain property id/value pairs to set once the element is created.</param>
		public InPort(DslModeling::Partition partition, params DslModeling::PropertyAssignment[] propertyAssignments)
			: base(partition, propertyAssignments)
		{
		}
		#endregion
		#region Sources opposite domain role accessor
		
		/// <summary>
		/// Gets a list of Sources.
		/// </summary>
		public virtual DslModeling::LinkedElementCollection<OutPort> Sources
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get
			{
				return GetRoleCollection<DslModeling::LinkedElementCollection<OutPort>, OutPort>(global::Company.MobileDSL.Connection.TargetDomainRoleId);
			}
		}
		#endregion
	}
}
namespace Company.MobileDSL
{
	/// <summary>
	/// DomainClass OutPort
	/// </summary>
	[DslDesign::DisplayNameResource("Company.MobileDSL.OutPort.DisplayName", typeof(global::Company.MobileDSL.MobileDSLDomainModel), "Company.MobileDSL.GeneratedCode.DomainModelResx")]
	[DslDesign::DescriptionResource("Company.MobileDSL.OutPort.Description", typeof(global::Company.MobileDSL.MobileDSLDomainModel), "Company.MobileDSL.GeneratedCode.DomainModelResx")]
	[DslModeling::DomainModelOwner(typeof(global::Company.MobileDSL.MobileDSLDomainModel))]
	[global::System.CLSCompliant(true)]
	[DslModeling::DomainObjectId("71899fcc-9a47-4fed-a025-7fc91b6a8ecd")]
	public partial class OutPort : Port
	{
		#region Constructors, domain class Id
	
		/// <summary>
		/// OutPort domain class Id.
		/// </summary>
		public static readonly new global::System.Guid DomainClassId = new global::System.Guid(0x71899fcc, 0x9a47, 0x4fed, 0xa0, 0x25, 0x7f, 0xc9, 0x1b, 0x6a, 0x8e, 0xcd);
		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="store">Store where new element is to be created.</param>
		/// <param name="propertyAssignments">List of domain property id/value pairs to set once the element is created.</param>
		public OutPort(DslModeling::Store store, params DslModeling::PropertyAssignment[] propertyAssignments)
			: this(store != null ? store.DefaultPartitionForClass(DomainClassId) : null, propertyAssignments)
		{
		}
		
		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="partition">Partition where new element is to be created.</param>
		/// <param name="propertyAssignments">List of domain property id/value pairs to set once the element is created.</param>
		public OutPort(DslModeling::Partition partition, params DslModeling::PropertyAssignment[] propertyAssignments)
			: base(partition, propertyAssignments)
		{
		}
		#endregion
		#region Targets opposite domain role accessor
		
		/// <summary>
		/// Gets a list of Targets.
		/// </summary>
		public virtual DslModeling::LinkedElementCollection<InPort> Targets
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get
			{
				return GetRoleCollection<DslModeling::LinkedElementCollection<InPort>, InPort>(global::Company.MobileDSL.Connection.SourceDomainRoleId);
			}
		}
		#endregion
	}
}
namespace Company.MobileDSL
{
	/// <summary>
	/// DomainClass Comment
	/// </summary>
	[DslDesign::DisplayNameResource("Company.MobileDSL.Comment.DisplayName", typeof(global::Company.MobileDSL.MobileDSLDomainModel), "Company.MobileDSL.GeneratedCode.DomainModelResx")]
	[DslDesign::DescriptionResource("Company.MobileDSL.Comment.Description", typeof(global::Company.MobileDSL.MobileDSLDomainModel), "Company.MobileDSL.GeneratedCode.DomainModelResx")]
	[DslModeling::DomainModelOwner(typeof(global::Company.MobileDSL.MobileDSLDomainModel))]
	[global::System.CLSCompliant(true)]
	[DslModeling::DomainObjectId("407f28da-8152-46e0-84dc-b299c4578399")]
	public partial class Comment : DslModeling::ModelElement
	{
		#region Constructors, domain class Id
	
		/// <summary>
		/// Comment domain class Id.
		/// </summary>
		public static readonly new global::System.Guid DomainClassId = new global::System.Guid(0x407f28da, 0x8152, 0x46e0, 0x84, 0xdc, 0xb2, 0x99, 0xc4, 0x57, 0x83, 0x99);
		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="store">Store where new element is to be created.</param>
		/// <param name="propertyAssignments">List of domain property id/value pairs to set once the element is created.</param>
		public Comment(DslModeling::Store store, params DslModeling::PropertyAssignment[] propertyAssignments)
			: this(store != null ? store.DefaultPartitionForClass(DomainClassId) : null, propertyAssignments)
		{
		}
		
		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="partition">Partition where new element is to be created.</param>
		/// <param name="propertyAssignments">List of domain property id/value pairs to set once the element is created.</param>
		public Comment(DslModeling::Partition partition, params DslModeling::PropertyAssignment[] propertyAssignments)
			: base(partition, propertyAssignments)
		{
		}
		#endregion
		#region Text domain property code
		
		/// <summary>
		/// Text domain property Id.
		/// </summary>
		public static readonly global::System.Guid TextDomainPropertyId = new global::System.Guid(0x6e548434, 0x483b, 0x48a6, 0xb2, 0x85, 0x94, 0x7b, 0x84, 0x0e, 0x32, 0x3f);
		
		/// <summary>
		/// Storage for Text
		/// </summary>
		private global::System.String textPropertyStorage = string.Empty;
		
		/// <summary>
		/// Gets or sets the value of Text domain property.
		/// </summary>
		[DslDesign::DisplayNameResource("Company.MobileDSL.Comment/Text.DisplayName", typeof(global::Company.MobileDSL.MobileDSLDomainModel), "Company.MobileDSL.GeneratedCode.DomainModelResx")]
		[DslDesign::DescriptionResource("Company.MobileDSL.Comment/Text.Description", typeof(global::Company.MobileDSL.MobileDSLDomainModel), "Company.MobileDSL.GeneratedCode.DomainModelResx")]
		[global::System.ComponentModel.DefaultValue("")]
		[DslModeling::DomainObjectId("6e548434-483b-48a6-b285-947b840e323f")]
		public global::System.String Text
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get
			{
				return textPropertyStorage;
			}
			[global::System.Diagnostics.DebuggerStepThrough]
			set
			{
				TextPropertyHandler.Instance.SetValue(this, value);
			}
		}
		/// <summary>
		/// Value handler for the Comment.Text domain property.
		/// </summary>
		internal sealed partial class TextPropertyHandler : DslModeling::DomainPropertyValueHandler<Comment, global::System.String>
		{
			private TextPropertyHandler() { }
		
			/// <summary>
			/// Gets the singleton instance of the Comment.Text domain property value handler.
			/// </summary>
			public static readonly TextPropertyHandler Instance = new TextPropertyHandler();
		
			/// <summary>
			/// Gets the Id of the Comment.Text domain property.
			/// </summary>
			public sealed override global::System.Guid DomainPropertyId
			{
				[global::System.Diagnostics.DebuggerStepThrough]
				get
				{
					return TextDomainPropertyId;
				}
			}
			
			/// <summary>
			/// Gets a strongly-typed value of the property on specified element.
			/// </summary>
			/// <param name="element">Element which owns the property.</param>
			/// <returns>Property value.</returns>
			public override sealed global::System.String GetValue(Comment element)
			{
				if (element == null) throw new global::System.ArgumentNullException("element");
				return element.textPropertyStorage;
			}
		
			/// <summary>
			/// Sets property value on an element.
			/// </summary>
			/// <param name="element">Element which owns the property.</param>
			/// <param name="newValue">New property value.</param>
			public override sealed void SetValue(Comment element, global::System.String newValue)
			{
				if (element == null) throw new global::System.ArgumentNullException("element");
		
				global::System.String oldValue = GetValue(element);
				if (newValue != oldValue)
				{
					ValueChanging(element, oldValue, newValue);
					element.textPropertyStorage = newValue;
					ValueChanged(element, oldValue, newValue);
				}
			}
		}
		
		#endregion
		#region ComponentModel opposite domain role accessor
		/// <summary>
		/// Gets or sets ComponentModel.
		/// </summary>
		public virtual ComponentModel ComponentModel
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get
			{
				return DslModeling::DomainRoleInfo.GetLinkedElement(this, global::Company.MobileDSL.ComponentModelHasComments.CommentDomainRoleId) as ComponentModel;
			}
			[global::System.Diagnostics.DebuggerStepThrough]
			set
			{
				DslModeling::DomainRoleInfo.SetLinkedElement(this, global::Company.MobileDSL.ComponentModelHasComments.CommentDomainRoleId, value);
			}
		}
		#endregion
		#region Subjects opposite domain role accessor
		
		/// <summary>
		/// Gets a list of Subjects.
		/// </summary>
		public virtual DslModeling::LinkedElementCollection<Controller> Subjects
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get
			{
				return GetRoleCollection<DslModeling::LinkedElementCollection<Controller>, Controller>(global::Company.MobileDSL.CommentReferencesSubjects.CommentDomainRoleId);
			}
		}
		#endregion
	}
}
namespace Company.MobileDSL
{
	/// <summary>
	/// DomainClass State_old
	/// Description for Company.MobileDSL.State_old
	/// </summary>
	[DslDesign::DisplayNameResource("Company.MobileDSL.State_old.DisplayName", typeof(global::Company.MobileDSL.MobileDSLDomainModel), "Company.MobileDSL.GeneratedCode.DomainModelResx")]
	[DslDesign::DescriptionResource("Company.MobileDSL.State_old.Description", typeof(global::Company.MobileDSL.MobileDSLDomainModel), "Company.MobileDSL.GeneratedCode.DomainModelResx")]
	[DslModeling::DomainModelOwner(typeof(global::Company.MobileDSL.MobileDSLDomainModel))]
	[global::System.CLSCompliant(true)]
	[DslModeling::DomainObjectId("9d18e10e-3276-4fd5-9993-78854d051ee0")]
	public partial class State_old : NamedElement
	{
		#region Constructors, domain class Id
	
		/// <summary>
		/// State_old domain class Id.
		/// </summary>
		public static readonly new global::System.Guid DomainClassId = new global::System.Guid(0x9d18e10e, 0x3276, 0x4fd5, 0x99, 0x93, 0x78, 0x85, 0x4d, 0x05, 0x1e, 0xe0);
		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="store">Store where new element is to be created.</param>
		/// <param name="propertyAssignments">List of domain property id/value pairs to set once the element is created.</param>
		public State_old(DslModeling::Store store, params DslModeling::PropertyAssignment[] propertyAssignments)
			: this(store != null ? store.DefaultPartitionForClass(DomainClassId) : null, propertyAssignments)
		{
		}
		
		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="partition">Partition where new element is to be created.</param>
		/// <param name="propertyAssignments">List of domain property id/value pairs to set once the element is created.</param>
		public State_old(DslModeling::Partition partition, params DslModeling::PropertyAssignment[] propertyAssignments)
			: base(partition, propertyAssignments)
		{
		}
		#endregion
		#region isFirstState domain property code
		
		/// <summary>
		/// isFirstState domain property Id.
		/// </summary>
		public static readonly global::System.Guid isFirstStateDomainPropertyId = new global::System.Guid(0xcf27c57d, 0xf48f, 0x4dd8, 0x8d, 0x37, 0xbf, 0xa1, 0x72, 0x0f, 0xdd, 0x86);
		
		/// <summary>
		/// Storage for isFirstState
		/// </summary>
		private global::System.Boolean isFirstStatePropertyStorage;
		
		/// <summary>
		/// Gets or sets the value of isFirstState domain property.
		/// Description for Company.MobileDSL.State_old.Is First State
		/// </summary>
		[DslDesign::DisplayNameResource("Company.MobileDSL.State_old/isFirstState.DisplayName", typeof(global::Company.MobileDSL.MobileDSLDomainModel), "Company.MobileDSL.GeneratedCode.DomainModelResx")]
		[DslDesign::DescriptionResource("Company.MobileDSL.State_old/isFirstState.Description", typeof(global::Company.MobileDSL.MobileDSLDomainModel), "Company.MobileDSL.GeneratedCode.DomainModelResx")]
		[DslModeling::DomainObjectId("cf27c57d-f48f-4dd8-8d37-bfa1720fdd86")]
		public global::System.Boolean isFirstState
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get
			{
				return isFirstStatePropertyStorage;
			}
			[global::System.Diagnostics.DebuggerStepThrough]
			set
			{
				isFirstStatePropertyHandler.Instance.SetValue(this, value);
			}
		}
		/// <summary>
		/// Value handler for the State_old.isFirstState domain property.
		/// </summary>
		internal sealed partial class isFirstStatePropertyHandler : DslModeling::DomainPropertyValueHandler<State_old, global::System.Boolean>
		{
			private isFirstStatePropertyHandler() { }
		
			/// <summary>
			/// Gets the singleton instance of the State_old.isFirstState domain property value handler.
			/// </summary>
			public static readonly isFirstStatePropertyHandler Instance = new isFirstStatePropertyHandler();
		
			/// <summary>
			/// Gets the Id of the State_old.isFirstState domain property.
			/// </summary>
			public sealed override global::System.Guid DomainPropertyId
			{
				[global::System.Diagnostics.DebuggerStepThrough]
				get
				{
					return isFirstStateDomainPropertyId;
				}
			}
			
			/// <summary>
			/// Gets a strongly-typed value of the property on specified element.
			/// </summary>
			/// <param name="element">Element which owns the property.</param>
			/// <returns>Property value.</returns>
			public override sealed global::System.Boolean GetValue(State_old element)
			{
				if (element == null) throw new global::System.ArgumentNullException("element");
				return element.isFirstStatePropertyStorage;
			}
		
			/// <summary>
			/// Sets property value on an element.
			/// </summary>
			/// <param name="element">Element which owns the property.</param>
			/// <param name="newValue">New property value.</param>
			public override sealed void SetValue(State_old element, global::System.Boolean newValue)
			{
				if (element == null) throw new global::System.ArgumentNullException("element");
		
				global::System.Boolean oldValue = GetValue(element);
				if (newValue != oldValue)
				{
					ValueChanging(element, oldValue, newValue);
					element.isFirstStatePropertyStorage = newValue;
					ValueChanged(element, oldValue, newValue);
				}
			}
		}
		
		#endregion
		#region Controller opposite domain role accessor
		/// <summary>
		/// Gets or sets Controller.
		/// Description for Company.MobileDSL.ControllerHasStates.State_old
		/// </summary>
		public virtual Controller Controller
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get
			{
				return DslModeling::DomainRoleInfo.GetLinkedElement(this, global::Company.MobileDSL.ControllerHasStates.State_oldDomainRoleId) as Controller;
			}
			[global::System.Diagnostics.DebuggerStepThrough]
			set
			{
				DslModeling::DomainRoleInfo.SetLinkedElement(this, global::Company.MobileDSL.ControllerHasStates.State_oldDomainRoleId, value);
			}
		}
		#endregion
		#region PreviousStates opposite domain role accessor
		
		/// <summary>
		/// Gets a list of PreviousStates.
		/// Description for
		/// Company.MobileDSL.State_oldReferencesPreviousStates.SourceState_old
		/// </summary>
		public virtual DslModeling::LinkedElementCollection<State_old> PreviousStates
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get
			{
				return GetRoleCollection<DslModeling::LinkedElementCollection<State_old>, State_old>(global::Company.MobileDSL.State_oldReferencesPreviousStates.SourceState_oldDomainRoleId);
			}
		}
		#endregion
		#region NextStates opposite domain role accessor
		
		/// <summary>
		/// Gets a list of NextStates.
		/// Description for
		/// Company.MobileDSL.State_oldReferencesPreviousStates.TargetState_old
		/// </summary>
		public virtual DslModeling::LinkedElementCollection<State_old> NextStates
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get
			{
				return GetRoleCollection<DslModeling::LinkedElementCollection<State_old>, State_old>(global::Company.MobileDSL.State_oldReferencesPreviousStates.TargetState_oldDomainRoleId);
			}
		}
		#endregion
		#region Ports opposite domain role accessor
		
		/// <summary>
		/// Gets a list of Ports.
		/// Description for Company.MobileDSL.State_oldHasPorts.State_old
		/// </summary>
		public virtual DslModeling::LinkedElementCollection<Port> Ports
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get
			{
				return GetRoleCollection<DslModeling::LinkedElementCollection<Port>, Port>(global::Company.MobileDSL.State_oldHasPorts.State_oldDomainRoleId);
			}
		}
		#endregion
		#region ElementGroupPrototype Merge methods
		/// <summary>
		/// Returns a value indicating whether the source element represented by the
		/// specified root ProtoElement can be added to this element.
		/// </summary>
		/// <param name="rootElement">
		/// The root ProtoElement representing a source element.  This can be null, 
		/// in which case the ElementGroupPrototype does not contain an ProtoElements
		/// and the code should inspect the ElementGroupPrototype context information.
		/// </param>
		/// <param name="elementGroupPrototype">The ElementGroupPrototype that contains the root ProtoElement.</param>
		/// <returns>true if the source element represented by the ProtoElement can be added to this target element.</returns>
		protected override bool CanMerge(DslModeling::ProtoElementBase rootElement, DslModeling::ElementGroupPrototype elementGroupPrototype)
		{
			if ( elementGroupPrototype == null ) throw new global::System.ArgumentNullException("elementGroupPrototype");
			
			if (rootElement != null)
			{
				DslModeling::DomainClassInfo rootElementDomainInfo = this.Partition.DomainDataDirectory.GetDomainClass(rootElement.DomainClassId);
				
				if (rootElementDomainInfo.IsDerivedFrom(global::Company.MobileDSL.Port.DomainClassId)) 
				{
					return true;
				}
			}
			return base.CanMerge(rootElement, elementGroupPrototype);
		}
		
		/// <summary>
		/// Called by the Merge process to create a relationship between 
		/// this target element and the specified source element. 
		/// Typically, a parent-child relationship is established
		/// between the target element (the parent) and the source element 
		/// (the child), but any relationship can be established.
		/// </summary>
		/// <param name="sourceElement">The element that is to be related to this model element.</param>
		/// <param name="elementGroup">The group of source ModelElements that have been rehydrated into the target store.</param>
		/// <remarks>
		/// This method is overriden to create the relationship between the target element and the specified source element.
		/// The base method does nothing.
		/// </remarks>
		protected override void MergeRelate(DslModeling::ModelElement sourceElement, DslModeling::ElementGroup elementGroup)
		{
			// In general, sourceElement is allowed to be null, meaning that the elementGroup must be parsed for special cases.
			// However this is not supported in generated code.  Use double-deriving on this class and then override MergeRelate completely if you 
			// need to support this case.
			if ( sourceElement == null ) throw new global::System.ArgumentNullException("sourceElement");
		
				
			global::Company.MobileDSL.Port sourcePort1 = sourceElement as global::Company.MobileDSL.Port;
			if (sourcePort1 != null)
			{
				// Create link for path State_oldHasPorts.Ports
				this.Ports.Add(sourcePort1);

				return;
			}
		
			// Sdk workaround to runtime bug #879350 (DSL: can't copy and paste a MEL that has a MEX). Avoid MergeRelate on ModelElementExtension
			// during a "Paste".
			if (sourceElement is DslModeling::ExtensionElement
				&& sourceElement.Store.TransactionManager.CurrentTransaction.TopLevelTransaction.Context.ContextInfo.ContainsKey("{9DAFD42A-DC0E-4d78-8C3F-8266B2CF8B33}"))
			{
				return;
			}
		
			// Fall through to base class if this class hasn't handled the merge.
			base.MergeRelate(sourceElement, elementGroup);
		}
		
		/// <summary>
		/// Performs operation opposite to MergeRelate - i.e. disconnects a given
		/// element from the current one (removes links created by MergeRelate).
		/// </summary>
		/// <param name="sourceElement">Element to be unmerged/disconnected.</param>
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1800:DoNotCastUnnecessarily")]
		protected override void MergeDisconnect(DslModeling::ModelElement sourceElement)
		{
			if (sourceElement == null) throw new global::System.ArgumentNullException("sourceElement");
				
			global::Company.MobileDSL.Port sourcePort1 = sourceElement as global::Company.MobileDSL.Port;
			if (sourcePort1 != null)
			{
				// Delete link for path State_oldHasPorts.Ports
				
				foreach (DslModeling::ElementLink link in global::Company.MobileDSL.State_oldHasPorts.GetLinks((global::Company.MobileDSL.State_old)this, sourcePort1))
				{
					// Delete the link, but without possible delete propagation to the element since it's moving to a new location.
					link.Delete(global::Company.MobileDSL.State_oldHasPorts.State_oldDomainRoleId, global::Company.MobileDSL.State_oldHasPorts.PortDomainRoleId);
				}

				return;
			}
			// Fall through to base class if this class hasn't handled the unmerge.
			base.MergeDisconnect(sourceElement);
		}
		#endregion
	}
}
namespace Company.MobileDSL
{
	/// <summary>
	/// DomainClass State
	/// Description for Company.MobileDSL.State
	/// </summary>
	[DslDesign::DisplayNameResource("Company.MobileDSL.State.DisplayName", typeof(global::Company.MobileDSL.MobileDSLDomainModel), "Company.MobileDSL.GeneratedCode.DomainModelResx")]
	[DslDesign::DescriptionResource("Company.MobileDSL.State.Description", typeof(global::Company.MobileDSL.MobileDSLDomainModel), "Company.MobileDSL.GeneratedCode.DomainModelResx")]
	[DslModeling::DomainModelOwner(typeof(global::Company.MobileDSL.MobileDSLDomainModel))]
	[global::System.CLSCompliant(true)]
	[DslModeling::DomainObjectId("c10a167b-d931-4f22-913b-8b5210fdfade")]
	public partial class State : NamedElement
	{
		#region Constructors, domain class Id
	
		/// <summary>
		/// State domain class Id.
		/// </summary>
		public static readonly new global::System.Guid DomainClassId = new global::System.Guid(0xc10a167b, 0xd931, 0x4f22, 0x91, 0x3b, 0x8b, 0x52, 0x10, 0xfd, 0xfa, 0xde);
		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="store">Store where new element is to be created.</param>
		/// <param name="propertyAssignments">List of domain property id/value pairs to set once the element is created.</param>
		public State(DslModeling::Store store, params DslModeling::PropertyAssignment[] propertyAssignments)
			: this(store != null ? store.DefaultPartitionForClass(DomainClassId) : null, propertyAssignments)
		{
		}
		
		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="partition">Partition where new element is to be created.</param>
		/// <param name="propertyAssignments">List of domain property id/value pairs to set once the element is created.</param>
		public State(DslModeling::Partition partition, params DslModeling::PropertyAssignment[] propertyAssignments)
			: base(partition, propertyAssignments)
		{
		}
		#endregion
		#region Controller opposite domain role accessor
		/// <summary>
		/// Gets or sets Controller.
		/// Description for Company.MobileDSL.ControllerHasStated.State
		/// </summary>
		public virtual Controller Controller
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get
			{
				return DslModeling::DomainRoleInfo.GetLinkedElement(this, global::Company.MobileDSL.ControllerHasStated.StateDomainRoleId) as Controller;
			}
			[global::System.Diagnostics.DebuggerStepThrough]
			set
			{
				DslModeling::DomainRoleInfo.SetLinkedElement(this, global::Company.MobileDSL.ControllerHasStated.StateDomainRoleId, value);
			}
		}
		#endregion
		#region Ports opposite domain role accessor
		
		/// <summary>
		/// Gets a list of Ports.
		/// Description for Company.MobileDSL.StateHasPorts.State
		/// </summary>
		public virtual DslModeling::LinkedElementCollection<Port> Ports
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get
			{
				return GetRoleCollection<DslModeling::LinkedElementCollection<Port>, Port>(global::Company.MobileDSL.StateHasPorts.StateDomainRoleId);
			}
		}
		#endregion
		#region ElementGroupPrototype Merge methods
		/// <summary>
		/// Returns a value indicating whether the source element represented by the
		/// specified root ProtoElement can be added to this element.
		/// </summary>
		/// <param name="rootElement">
		/// The root ProtoElement representing a source element.  This can be null, 
		/// in which case the ElementGroupPrototype does not contain an ProtoElements
		/// and the code should inspect the ElementGroupPrototype context information.
		/// </param>
		/// <param name="elementGroupPrototype">The ElementGroupPrototype that contains the root ProtoElement.</param>
		/// <returns>true if the source element represented by the ProtoElement can be added to this target element.</returns>
		protected override bool CanMerge(DslModeling::ProtoElementBase rootElement, DslModeling::ElementGroupPrototype elementGroupPrototype)
		{
			if ( elementGroupPrototype == null ) throw new global::System.ArgumentNullException("elementGroupPrototype");
			
			if (rootElement != null)
			{
				DslModeling::DomainClassInfo rootElementDomainInfo = this.Partition.DomainDataDirectory.GetDomainClass(rootElement.DomainClassId);
				
				if (rootElementDomainInfo.IsDerivedFrom(global::Company.MobileDSL.Port.DomainClassId)) 
				{
					return true;
				}
			}
			return base.CanMerge(rootElement, elementGroupPrototype);
		}
		
		/// <summary>
		/// Called by the Merge process to create a relationship between 
		/// this target element and the specified source element. 
		/// Typically, a parent-child relationship is established
		/// between the target element (the parent) and the source element 
		/// (the child), but any relationship can be established.
		/// </summary>
		/// <param name="sourceElement">The element that is to be related to this model element.</param>
		/// <param name="elementGroup">The group of source ModelElements that have been rehydrated into the target store.</param>
		/// <remarks>
		/// This method is overriden to create the relationship between the target element and the specified source element.
		/// The base method does nothing.
		/// </remarks>
		protected override void MergeRelate(DslModeling::ModelElement sourceElement, DslModeling::ElementGroup elementGroup)
		{
			// In general, sourceElement is allowed to be null, meaning that the elementGroup must be parsed for special cases.
			// However this is not supported in generated code.  Use double-deriving on this class and then override MergeRelate completely if you 
			// need to support this case.
			if ( sourceElement == null ) throw new global::System.ArgumentNullException("sourceElement");
		
				
			global::Company.MobileDSL.Port sourcePort1 = sourceElement as global::Company.MobileDSL.Port;
			if (sourcePort1 != null)
			{
				// Create link for path StateHasPorts.Ports
				this.Ports.Add(sourcePort1);

				return;
			}
		
			// Sdk workaround to runtime bug #879350 (DSL: can't copy and paste a MEL that has a MEX). Avoid MergeRelate on ModelElementExtension
			// during a "Paste".
			if (sourceElement is DslModeling::ExtensionElement
				&& sourceElement.Store.TransactionManager.CurrentTransaction.TopLevelTransaction.Context.ContextInfo.ContainsKey("{9DAFD42A-DC0E-4d78-8C3F-8266B2CF8B33}"))
			{
				return;
			}
		
			// Fall through to base class if this class hasn't handled the merge.
			base.MergeRelate(sourceElement, elementGroup);
		}
		
		/// <summary>
		/// Performs operation opposite to MergeRelate - i.e. disconnects a given
		/// element from the current one (removes links created by MergeRelate).
		/// </summary>
		/// <param name="sourceElement">Element to be unmerged/disconnected.</param>
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1800:DoNotCastUnnecessarily")]
		protected override void MergeDisconnect(DslModeling::ModelElement sourceElement)
		{
			if (sourceElement == null) throw new global::System.ArgumentNullException("sourceElement");
				
			global::Company.MobileDSL.Port sourcePort1 = sourceElement as global::Company.MobileDSL.Port;
			if (sourcePort1 != null)
			{
				// Delete link for path StateHasPorts.Ports
				
				foreach (DslModeling::ElementLink link in global::Company.MobileDSL.StateHasPorts.GetLinks((global::Company.MobileDSL.State)this, sourcePort1))
				{
					// Delete the link, but without possible delete propagation to the element since it's moving to a new location.
					link.Delete(global::Company.MobileDSL.StateHasPorts.StateDomainRoleId, global::Company.MobileDSL.StateHasPorts.PortDomainRoleId);
				}

				return;
			}
			// Fall through to base class if this class hasn't handled the unmerge.
			base.MergeDisconnect(sourceElement);
		}
		#endregion
	}
}
namespace Company.MobileDSL
{
	/// <summary>
	/// DomainClass TempClass
	/// Description for Company.MobileDSL.TempClass
	/// </summary>
	[DslDesign::DisplayNameResource("Company.MobileDSL.TempClass.DisplayName", typeof(global::Company.MobileDSL.MobileDSLDomainModel), "Company.MobileDSL.GeneratedCode.DomainModelResx")]
	[DslDesign::DescriptionResource("Company.MobileDSL.TempClass.Description", typeof(global::Company.MobileDSL.MobileDSLDomainModel), "Company.MobileDSL.GeneratedCode.DomainModelResx")]
	[DslModeling::DomainModelOwner(typeof(global::Company.MobileDSL.MobileDSLDomainModel))]
	[global::System.CLSCompliant(true)]
	[DslModeling::DomainObjectId("9dc4f661-da0f-4455-a2e2-87c366c7bbd5")]
	public partial class TempClass : DslModeling::ModelElement
	{
		#region Constructors, domain class Id
	
		/// <summary>
		/// TempClass domain class Id.
		/// </summary>
		public static readonly new global::System.Guid DomainClassId = new global::System.Guid(0x9dc4f661, 0xda0f, 0x4455, 0xa2, 0xe2, 0x87, 0xc3, 0x66, 0xc7, 0xbb, 0xd5);
		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="store">Store where new element is to be created.</param>
		/// <param name="propertyAssignments">List of domain property id/value pairs to set once the element is created.</param>
		public TempClass(DslModeling::Store store, params DslModeling::PropertyAssignment[] propertyAssignments)
			: this(store != null ? store.DefaultPartitionForClass(DomainClassId) : null, propertyAssignments)
		{
		}
		
		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="partition">Partition where new element is to be created.</param>
		/// <param name="propertyAssignments">List of domain property id/value pairs to set once the element is created.</param>
		public TempClass(DslModeling::Partition partition, params DslModeling::PropertyAssignment[] propertyAssignments)
			: base(partition, propertyAssignments)
		{
		}
		#endregion
		#region ComponentModel opposite domain role accessor
		/// <summary>
		/// Gets or sets ComponentModel.
		/// Description for Company.MobileDSL.ComponentModelHasTempClassed.TempClass
		/// </summary>
		public virtual ComponentModel ComponentModel
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get
			{
				return DslModeling::DomainRoleInfo.GetLinkedElement(this, global::Company.MobileDSL.ComponentModelHasTempClassed.TempClassDomainRoleId) as ComponentModel;
			}
			[global::System.Diagnostics.DebuggerStepThrough]
			set
			{
				DslModeling::DomainRoleInfo.SetLinkedElement(this, global::Company.MobileDSL.ComponentModelHasTempClassed.TempClassDomainRoleId, value);
			}
		}
		#endregion
		#region Ports opposite domain role accessor
		
		/// <summary>
		/// Gets a list of Ports.
		/// Description for Company.MobileDSL.TempClassHasPorts.TempClass
		/// </summary>
		public virtual DslModeling::LinkedElementCollection<Port> Ports
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get
			{
				return GetRoleCollection<DslModeling::LinkedElementCollection<Port>, Port>(global::Company.MobileDSL.TempClassHasPorts.TempClassDomainRoleId);
			}
		}
		#endregion
		#region StatePorts opposite domain role accessor
		
		/// <summary>
		/// Gets a list of StatePorts.
		/// Description for Company.MobileDSL.TempClassHasStatePorts.TempClass
		/// </summary>
		public virtual DslModeling::LinkedElementCollection<StatePort> StatePorts
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get
			{
				return GetRoleCollection<DslModeling::LinkedElementCollection<StatePort>, StatePort>(global::Company.MobileDSL.TempClassHasStatePorts.TempClassDomainRoleId);
			}
		}
		#endregion
		#region ElementGroupPrototype Merge methods
		/// <summary>
		/// Returns a value indicating whether the source element represented by the
		/// specified root ProtoElement can be added to this element.
		/// </summary>
		/// <param name="rootElement">
		/// The root ProtoElement representing a source element.  This can be null, 
		/// in which case the ElementGroupPrototype does not contain an ProtoElements
		/// and the code should inspect the ElementGroupPrototype context information.
		/// </param>
		/// <param name="elementGroupPrototype">The ElementGroupPrototype that contains the root ProtoElement.</param>
		/// <returns>true if the source element represented by the ProtoElement can be added to this target element.</returns>
		protected override bool CanMerge(DslModeling::ProtoElementBase rootElement, DslModeling::ElementGroupPrototype elementGroupPrototype)
		{
			if ( elementGroupPrototype == null ) throw new global::System.ArgumentNullException("elementGroupPrototype");
			
			if (rootElement != null)
			{
				DslModeling::DomainClassInfo rootElementDomainInfo = this.Partition.DomainDataDirectory.GetDomainClass(rootElement.DomainClassId);
				
				if (rootElementDomainInfo.IsDerivedFrom(global::Company.MobileDSL.Port.DomainClassId)) 
				{
					return true;
				}
				
				if (rootElementDomainInfo.IsDerivedFrom(global::Company.MobileDSL.StatePort.DomainClassId)) 
				{
					return true;
				}
			}
			return base.CanMerge(rootElement, elementGroupPrototype);
		}
		
		/// <summary>
		/// Called by the Merge process to create a relationship between 
		/// this target element and the specified source element. 
		/// Typically, a parent-child relationship is established
		/// between the target element (the parent) and the source element 
		/// (the child), but any relationship can be established.
		/// </summary>
		/// <param name="sourceElement">The element that is to be related to this model element.</param>
		/// <param name="elementGroup">The group of source ModelElements that have been rehydrated into the target store.</param>
		/// <remarks>
		/// This method is overriden to create the relationship between the target element and the specified source element.
		/// The base method does nothing.
		/// </remarks>
		protected override void MergeRelate(DslModeling::ModelElement sourceElement, DslModeling::ElementGroup elementGroup)
		{
			// In general, sourceElement is allowed to be null, meaning that the elementGroup must be parsed for special cases.
			// However this is not supported in generated code.  Use double-deriving on this class and then override MergeRelate completely if you 
			// need to support this case.
			if ( sourceElement == null ) throw new global::System.ArgumentNullException("sourceElement");
		
				
			global::Company.MobileDSL.Port sourcePort1 = sourceElement as global::Company.MobileDSL.Port;
			if (sourcePort1 != null)
			{
				// Create link for path TempClassHasPorts.Ports
				this.Ports.Add(sourcePort1);

				return;
			}
				
			global::Company.MobileDSL.StatePort sourceStatePort2 = sourceElement as global::Company.MobileDSL.StatePort;
			if (sourceStatePort2 != null)
			{
				// Create link for path TempClassHasStatePorts.StatePorts
				this.StatePorts.Add(sourceStatePort2);

				return;
			}
		
			// Sdk workaround to runtime bug #879350 (DSL: can't copy and paste a MEL that has a MEX). Avoid MergeRelate on ModelElementExtension
			// during a "Paste".
			if (sourceElement is DslModeling::ExtensionElement
				&& sourceElement.Store.TransactionManager.CurrentTransaction.TopLevelTransaction.Context.ContextInfo.ContainsKey("{9DAFD42A-DC0E-4d78-8C3F-8266B2CF8B33}"))
			{
				return;
			}
		
			// Fall through to base class if this class hasn't handled the merge.
			base.MergeRelate(sourceElement, elementGroup);
		}
		
		/// <summary>
		/// Performs operation opposite to MergeRelate - i.e. disconnects a given
		/// element from the current one (removes links created by MergeRelate).
		/// </summary>
		/// <param name="sourceElement">Element to be unmerged/disconnected.</param>
		[global::System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Performance", "CA1800:DoNotCastUnnecessarily")]
		protected override void MergeDisconnect(DslModeling::ModelElement sourceElement)
		{
			if (sourceElement == null) throw new global::System.ArgumentNullException("sourceElement");
				
			global::Company.MobileDSL.Port sourcePort1 = sourceElement as global::Company.MobileDSL.Port;
			if (sourcePort1 != null)
			{
				// Delete link for path TempClassHasPorts.Ports
				
				foreach (DslModeling::ElementLink link in global::Company.MobileDSL.TempClassHasPorts.GetLinks((global::Company.MobileDSL.TempClass)this, sourcePort1))
				{
					// Delete the link, but without possible delete propagation to the element since it's moving to a new location.
					link.Delete(global::Company.MobileDSL.TempClassHasPorts.TempClassDomainRoleId, global::Company.MobileDSL.TempClassHasPorts.PortDomainRoleId);
				}

				return;
			}
				
			global::Company.MobileDSL.StatePort sourceStatePort2 = sourceElement as global::Company.MobileDSL.StatePort;
			if (sourceStatePort2 != null)
			{
				// Delete link for path TempClassHasStatePorts.StatePorts
				
				foreach (DslModeling::ElementLink link in global::Company.MobileDSL.TempClassHasStatePorts.GetLinks((global::Company.MobileDSL.TempClass)this, sourceStatePort2))
				{
					// Delete the link, but without possible delete propagation to the element since it's moving to a new location.
					link.Delete(global::Company.MobileDSL.TempClassHasStatePorts.TempClassDomainRoleId, global::Company.MobileDSL.TempClassHasStatePorts.StatePortDomainRoleId);
				}

				return;
			}
			// Fall through to base class if this class hasn't handled the unmerge.
			base.MergeDisconnect(sourceElement);
		}
		#endregion
	}
}
namespace Company.MobileDSL
{
	/// <summary>
	/// DomainClass StatePort
	/// Description for Company.MobileDSL.StatePort
	/// </summary>
	[DslDesign::DisplayNameResource("Company.MobileDSL.StatePort.DisplayName", typeof(global::Company.MobileDSL.MobileDSLDomainModel), "Company.MobileDSL.GeneratedCode.DomainModelResx")]
	[DslDesign::DescriptionResource("Company.MobileDSL.StatePort.Description", typeof(global::Company.MobileDSL.MobileDSLDomainModel), "Company.MobileDSL.GeneratedCode.DomainModelResx")]
	[DslModeling::DomainModelOwner(typeof(global::Company.MobileDSL.MobileDSLDomainModel))]
	[global::System.CLSCompliant(true)]
	[global::System.Diagnostics.DebuggerDisplay("{GetType().Name,nq} (Name = {namePropertyStorage})")]
	[DslModeling::DomainObjectId("1b4a27fd-ba9d-4247-be99-fb1af96308ee")]
	public partial class StatePort : DslModeling::ModelElement
	{
		#region Constructors, domain class Id
	
		/// <summary>
		/// StatePort domain class Id.
		/// </summary>
		public static readonly new global::System.Guid DomainClassId = new global::System.Guid(0x1b4a27fd, 0xba9d, 0x4247, 0xbe, 0x99, 0xfb, 0x1a, 0xf9, 0x63, 0x08, 0xee);
		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="store">Store where new element is to be created.</param>
		/// <param name="propertyAssignments">List of domain property id/value pairs to set once the element is created.</param>
		public StatePort(DslModeling::Store store, params DslModeling::PropertyAssignment[] propertyAssignments)
			: this(store != null ? store.DefaultPartitionForClass(DomainClassId) : null, propertyAssignments)
		{
		}
		
		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="partition">Partition where new element is to be created.</param>
		/// <param name="propertyAssignments">List of domain property id/value pairs to set once the element is created.</param>
		public StatePort(DslModeling::Partition partition, params DslModeling::PropertyAssignment[] propertyAssignments)
			: base(partition, propertyAssignments)
		{
		}
		#endregion
		#region Name domain property code
		
		/// <summary>
		/// Name domain property Id.
		/// </summary>
		public static readonly global::System.Guid NameDomainPropertyId = new global::System.Guid(0x9dbed3c5, 0xcffe, 0x410c, 0xbc, 0xe4, 0xd9, 0x1e, 0x9e, 0xac, 0xb4, 0xe6);
		
		/// <summary>
		/// Storage for Name
		/// </summary>
		private global::System.String namePropertyStorage = string.Empty;
		
		/// <summary>
		/// Gets or sets the value of Name domain property.
		/// Description for Company.MobileDSL.StatePort.Name
		/// </summary>
		[DslDesign::DisplayNameResource("Company.MobileDSL.StatePort/Name.DisplayName", typeof(global::Company.MobileDSL.MobileDSLDomainModel), "Company.MobileDSL.GeneratedCode.DomainModelResx")]
		[DslDesign::DescriptionResource("Company.MobileDSL.StatePort/Name.Description", typeof(global::Company.MobileDSL.MobileDSLDomainModel), "Company.MobileDSL.GeneratedCode.DomainModelResx")]
		[DslModeling::ElementName]
		[DslModeling::DomainObjectId("9dbed3c5-cffe-410c-bce4-d91e9eacb4e6")]
		public global::System.String Name
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get
			{
				return namePropertyStorage;
			}
			[global::System.Diagnostics.DebuggerStepThrough]
			set
			{
				NamePropertyHandler.Instance.SetValue(this, value);
			}
		}
		/// <summary>
		/// Value handler for the StatePort.Name domain property.
		/// </summary>
		internal sealed partial class NamePropertyHandler : DslModeling::DomainPropertyValueHandler<StatePort, global::System.String>
		{
			private NamePropertyHandler() { }
		
			/// <summary>
			/// Gets the singleton instance of the StatePort.Name domain property value handler.
			/// </summary>
			public static readonly NamePropertyHandler Instance = new NamePropertyHandler();
		
			/// <summary>
			/// Gets the Id of the StatePort.Name domain property.
			/// </summary>
			public sealed override global::System.Guid DomainPropertyId
			{
				[global::System.Diagnostics.DebuggerStepThrough]
				get
				{
					return NameDomainPropertyId;
				}
			}
			
			/// <summary>
			/// Gets a strongly-typed value of the property on specified element.
			/// </summary>
			/// <param name="element">Element which owns the property.</param>
			/// <returns>Property value.</returns>
			public override sealed global::System.String GetValue(StatePort element)
			{
				if (element == null) throw new global::System.ArgumentNullException("element");
				return element.namePropertyStorage;
			}
		
			/// <summary>
			/// Sets property value on an element.
			/// </summary>
			/// <param name="element">Element which owns the property.</param>
			/// <param name="newValue">New property value.</param>
			public override sealed void SetValue(StatePort element, global::System.String newValue)
			{
				if (element == null) throw new global::System.ArgumentNullException("element");
		
				global::System.String oldValue = GetValue(element);
				if (newValue != oldValue)
				{
					ValueChanging(element, oldValue, newValue);
					element.namePropertyStorage = newValue;
					ValueChanged(element, oldValue, newValue);
				}
			}
		}
		
		#endregion
		#region TempClass opposite domain role accessor
		/// <summary>
		/// Gets or sets TempClass.
		/// Description for Company.MobileDSL.TempClassHasStatePorts.StatePort
		/// </summary>
		public virtual TempClass TempClass
		{
			[global::System.Diagnostics.DebuggerStepThrough]
			get
			{
				return DslModeling::DomainRoleInfo.GetLinkedElement(this, global::Company.MobileDSL.TempClassHasStatePorts.StatePortDomainRoleId) as TempClass;
			}
			[global::System.Diagnostics.DebuggerStepThrough]
			set
			{
				DslModeling::DomainRoleInfo.SetLinkedElement(this, global::Company.MobileDSL.TempClassHasStatePorts.StatePortDomainRoleId, value);
			}
		}
		#endregion
	}
}
